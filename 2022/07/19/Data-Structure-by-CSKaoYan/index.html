<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>data structure by cskaoyan | Bowlmeat&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="内功" />
  
  
  
  
  <meta name="description" content="树二叉树题目 一、通过前序遍历与中序遍历确定一棵二叉树  这代码还有问题，目前输出的还是前序遍历，明天再看一下，先去洗个澡。 1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F; 输出层次遍历结果 #include&lt;stdio.h&gt;void traverseTree(char pre[], char in[], int pr">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure by CSKaoYan">
<meta property="og:url" content="https://bowlmeat.github.io/2022/07/19/Data-Structure-by-CSKaoYan/index.html">
<meta property="og:site_name" content="Bowlmeat&#39;s Blogs">
<meta property="og:description" content="树二叉树题目 一、通过前序遍历与中序遍历确定一棵二叉树  这代码还有问题，目前输出的还是前序遍历，明天再看一下，先去洗个澡。 1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F; 输出层次遍历结果 #include&lt;stdio.h&gt;void traverseTree(char pre[], char in[], int pr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://latex.codecogs.com/svg.latex?Constructing%20%5Cleft%5C%7B%20%5Cbegin%7Baligned%7D%20PreOrder&+InOrder%20%5C%5C%20PostOrder&+InOrder%20%5C%5C%20LevelOrder&+InOrder%20%5Cend%7Baligned%7D%20%5Cright.">
<meta property="og:image" content="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clfloor%20log_2%20n+1%5Cbiggr%5Crfloor">
<meta property="og:image" content="https://s2.loli.net/2022/08/02/lOTh6jWaJwgoFMz.png">
<meta property="og:image" content="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20m/2%20%5Cbiggr%5Crceil%20-1%20%5Cleq%20n%20%5Cleq%20m-1">
<meta property="og:image" content="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20m/2%20%5Cbiggr%5Crceil">
<meta property="og:image" content="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20log_2%20m%5Cbiggr%5Crceil">
<meta property="og:image" content="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20log_2%20m%5Cbiggr%5Crceil">
<meta property="og:image" content="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clfloor%20log_2%20n%5Cbiggr%5Crfloor+1">
<meta property="article:published_time" content="2022-07-19T13:21:13.000Z">
<meta property="article:modified_time" content="2022-08-14T06:46:54.246Z">
<meta property="article:author" content="bowlmeat">
<meta property="article:tag" content="内功">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://latex.codecogs.com/svg.latex?Constructing%20%5Cleft%5C%7B%20%5Cbegin%7Baligned%7D%20PreOrder&+InOrder%20%5C%5C%20PostOrder&+InOrder%20%5C%5C%20LevelOrder&+InOrder%20%5Cend%7Baligned%7D%20%5Cright.">
  
    <link rel="alternate" href="/atom.xml" title="Bowlmeat&#39;s Blogs" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogoo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogoo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("/css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("/css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("/css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  
<link rel="stylesheet" href="../../../../css/style.css">


  
<script src="../../../../js/jquery-3.1.1.min.js"></script>

  
<script src="../../../../js/bootstrap.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    
<link rel="stylesheet" href="../../../../css/dialog.css">

  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

<meta name="generator" content="Hexo 5.4.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogoo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="../../../../index.html">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="../../../../about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '../../../../content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="../../../../js/insight.js"></script>


</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Data-Structure-by-CSKaoYan" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Data Structure by CSKaoYan
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="" class="article-date">
	  <time datetime="2022-07-19T13:21:13.000Z" itemprop="datePublished">2022-07-19</time>
	</a>

      
      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>题目</strong></p>
<p><strong>一、通过前序遍历与中序遍历确定一棵二叉树</strong></p>
<p><img src="https://latex.codecogs.com/svg.latex?Constructing%20%5Cleft%5C%7B%20%5Cbegin%7Baligned%7D%20PreOrder&+InOrder%20%5C%5C%20PostOrder&+InOrder%20%5C%5C%20LevelOrder&+InOrder%20%5Cend%7Baligned%7D%20%5Cright."></p>
<p>这代码还有问题，目前输出的还是前序遍历，明天再看一下，先去洗个澡。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出层次遍历结果 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseTree</span><span class="params">(<span class="keyword">char</span> pre[], <span class="keyword">char</span> in[], <span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(preLeft&gt;preRight||inLeft&gt;inRight) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> root = pre[preLeft];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, root);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 中序遍历中查找根节点的下标 </span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=inLeft;i&lt;=inRight;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(in[i]==root)&#123;</span><br><span class="line">			index=i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 左子树 </span></span><br><span class="line">	<span class="built_in">traverseTree</span>(pre, in, preLeft+<span class="number">1</span>, preLeft+index-inLeft, inLeft, index<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">// 右子树 </span></span><br><span class="line">	<span class="built_in">traverseTree</span>(pre, in, preRight-inRight+index+<span class="number">1</span>, preRight, index+<span class="number">1</span>, inRight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">/*char pre[]=&#123;&#x27;A&#x27;, &#x27;D&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;E&#x27;&#125;;</span></span><br><span class="line"><span class="comment">	char in[]=&#123;&#x27;B&#x27;, &#x27;D&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;E&#x27;&#125;;	</span></span><br><span class="line"><span class="comment">	traverseTree(pre, in, 0, 4, 0, 4);*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> pre[]=&#123;<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;I&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> in[]=&#123;<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;I&#x27;</span>&#125;;</span><br><span class="line">	<span class="built_in">traverseTree</span>(pre, in, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线索二叉树的概念"><a href="#线索二叉树的概念" class="headerlink" title="线索二叉树的概念"></a>线索二叉树的概念</h2><h3 id="线索二叉树的作用"><a href="#线索二叉树的作用" class="headerlink" title="线索二叉树的作用"></a>线索二叉树的作用</h3><ul>
<li>主要用于遍历序列</li>
<li>方便找前驱、后继以及遍历</li>
</ul>
<p>包括先序遍历、中序遍历、后序遍历线索二叉树</p>
<p>【线索】指向前驱、后继的指针称为线索</p>
<h3 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h3><p>二叉链表-线索链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ltag, rtag;  <span class="comment">// tag=1表示是指向为线索</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 土法找到中序前驱 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">vist</span>(root);</span><br><span class="line">	<span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在vist中完成线索化，只有在访问时才操作（访问序列）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vist</span><span class="params">(Node* node)</span></span>&#123;  </span><br><span class="line">	<span class="keyword">if</span>(node == <span class="keyword">final</span>) <span class="keyword">return</span> pre;</span><br><span class="line">	<span class="keyword">else</span> pre = node;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="在线索二叉树中找前驱后继"><a href="#在线索二叉树中找前驱后继" class="headerlink" title="在线索二叉树中找前驱后继"></a>在线索二叉树中找前驱后继</h2><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><ol>
<li><p>树是一种递归定义的数据结构</p>
</li>
<li><p>存储结构</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">双亲表示法</th>
<th align="center">孩子表示法</th>
<th align="center">孩子-兄弟表示法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储结构</td>
<td align="center">顺序存储</td>
<td align="center">顺序+链式(邻接表)</td>
<td align="center">链式</td>
</tr>
<tr>
<td align="center">增</td>
<td align="center">nodes[idx++]=node</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">删</td>
<td align="center">①nodes[k].p=-1或swap(node[idx],node[k]);②遍历全表删除p=k的子孙节点</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双亲表示法 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val; <span class="comment">// 值</span></span><br><span class="line">	<span class="keyword">int</span> p;   <span class="comment">// 父亲的序号，-1表示没有</span></span><br><span class="line">&#125;node[N];    <span class="comment">// 数组，第一个固定表示根节点(index=0)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	Node nodes[N];</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 孩子表示法 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Child</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Child</span>* <span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Child</span>* <span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	Node nodes[N];</span><br><span class="line">	<span class="keyword">int</span> n, r;     <span class="comment">// n为节点数，r为根位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 孩子-兄弟表示法 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">child</span>, *<span class="title">p</span>;</span> <span class="comment">// 左孩子右兄弟</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h2><table>
<thead>
<tr>
<th align="center">二叉树</th>
<th align="center">树</th>
<th align="center">森林</th>
</tr>
</thead>
<tbody><tr>
<td align="center">先序遍历</td>
<td align="center">先序遍历</td>
<td align="center">先序遍历</td>
</tr>
<tr>
<td align="center">中序遍历</td>
<td align="center">后序遍历</td>
<td align="center">中序遍历</td>
</tr>
</tbody></table>
<h2 id="127800-二叉排序树"><a href="#127800-二叉排序树" class="headerlink" title="&#127800;二叉排序树"></a>&#127800;二叉排序树</h2><blockquote>
<p>默认不允许两个节点关键字相同</p>
</blockquote>
<p><strong>&#128150;3595.二叉排序树</strong>-要求返回父节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, root;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; l, r;</span><br><span class="line"><span class="comment">// 建立BST</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">-1</span>)&#123;</span><br><span class="line">		root=x;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; f)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!r.<span class="built_in">count</span>(f))&#123;</span><br><span class="line">			r[f] = x;</span><br><span class="line">			<span class="keyword">return</span> f;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(r[f]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; f)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!l.<span class="built_in">count</span>(f))&#123;</span><br><span class="line">			l[f] = x;</span><br><span class="line">			<span class="keyword">return</span> f;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(l[f], x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历BST</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!l.<span class="built_in">count</span>(root)&amp;&amp;!r.<span class="built_in">count</span>(root))&#123;</span><br><span class="line">		cout&lt;&lt;root&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(l.<span class="built_in">count</span>(root)) <span class="built_in">visit</span>(l[root]);</span><br><span class="line">	cout&lt;&lt;root&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">if</span>(r.<span class="built_in">count</span>(root)) <span class="built_in">visit</span>(r[root]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root = <span class="number">-1</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">dfs</span>(root, x)&lt;&lt;endl;</span><br><span class="line"><span class="built_in">visit</span>(root);</span><br></pre></td></tr></table></figure>
<h3 id="BST查找"><a href="#BST查找" class="headerlink" title="BST查找"></a>BST查找</h3><p>迭代与递归</p>
<h3 id="BST插入与构造"><a href="#BST插入与构造" class="headerlink" title="BST插入与构造"></a>BST插入与构造</h3><h3 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><p>ASL：最好情况，n个节点的BST最小高度为<br><img src="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clfloor%20log_2%20n+1%5Cbiggr%5Crfloor"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><blockquote>
<p>平衡因子：左子树高-右子树高 -&gt; {-1,0,1}</p>
</blockquote>
<h3 id="调节BST至AVL"><a href="#调节BST至AVL" class="headerlink" title="调节BST至AVL"></a>调节BST至AVL</h3><p>调整最小不平衡子树：LL,RR,LR,RL</p>
<h3 id="查找效率分析-1"><a href="#查找效率分析-1" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h3><ol>
<li>节点的权：某种特定含义的数值</li>
<li>节点的带权路径长度：根到节点路径长度 * 节点的权值</li>
<li>树的带权路径长度(WPL) = 树中所有<font color="red"><strong>叶子节点</strong></font>的带权路径长度之和<h3 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h3></li>
</ol>
<ul>
<li><strong>最优二叉树</strong>：在含有给定的<strong>n个叶子节点</strong>的二叉树中，<strong>WPL最小</strong>的二叉树</li>
<li>不存在度为1的节点</li>
<li><strong>完全二叉树</strong>。总节点数：2n-1</li>
</ul>
<h3 id="哈夫曼树构造"><a href="#哈夫曼树构造" class="headerlink" title="哈夫曼树构造"></a>哈夫曼树构造</h3><p>（可以通过森林与集合对算法过程描述）</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><ol>
<li>固定长度编码 </li>
<li>可变长度编码</li>
<li>前缀编码</li>
</ol>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><blockquote>
<p>用于线性表</p>
</blockquote>
<ol>
<li>无序线性表：优化：a[0]设置哨兵</li>
<li>有序线性表：可优化查找失败ASL：查找判定树<ul>
<li>若被查到概率不同：可优化查找成功ASL<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><blockquote>
<p>用于顺序表</p>
</blockquote>
</li>
</ul>
</li>
<li>查找判定树</li>
<li>左右子树</li>
</ol>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><blockquote>
<p>索引顺序查找</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> maxVal;</span><br><span class="line">	<span class="keyword">int</span> low, high;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顺序表存储实际元素</span></span><br><span class="line"><span class="keyword">int</span> List[N];</span><br></pre></td></tr></table></figure>
<ul>
<li>扩展：动态查找表则可链式存储(否则静态数组仍需O(n)复杂度增删)</li>
</ul>
<ol>
<li>查找情况</li>
</ol>
<ul>
<li>索引表查找：顺序查找与二分查找</li>
<li>查找情况：<ul>
<li>索引表查到：直接返回</li>
<li>索引表未查到：low&gt;high，则low所指分块顺序查找；超出范围则失败</li>
</ul>
</li>
</ul>
<ol start="2">
<li>ASL<ul>
<li>索引表折半：索引未查到也需一直二分</li>
<li>ASL = 索引查找ASL + 块内查找ASL<img src="https://s2.loli.net/2022/08/02/lOTh6jWaJwgoFMz.png"></li>
</ul>
</li>
</ol>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><blockquote>
<p>多路平衡查找树；子树=关键字+1（关系）</p>
</blockquote>
<p><font color="red"><strong>最重要的：</strong></font></p>
<ol>
<li>对m阶B树，除根节点外，每个节点<strong>关键字</strong>数目：<br> <img src="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20m/2%20%5Cbiggr%5Crceil%20-1%20%5Cleq%20n%20%5Cleq%20m-1"></li>
<li>若根节点不是终端节点，则至少有2个子树</li>
<li>子树0&lt;关键字1&lt;子树1&lt;关键字2&lt;…</li>
<li>树中每个节点至多有m个子树、即最多m-1个关键字</li>
<li>所有叶子节点都在同一层次上且不带信息（即完全绝对平衡）</li>
</ol>
<ul>
<li>含有n个关键字的m叉B树的高度<br>【最小高度】</li>
</ul>
<p>记k=<img src="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20m/2%20%5Cbiggr%5Crceil"><br>|       | 最少节点数 |最少关键字|<br>| :———–: | :———–: |  :———–: |<br>|第一层|1|1|<br>|第二层|2|2(k-1)|<br>|第三层|2k|2k(k-1)|<br>|第四层|2k^2|2k^2(k-1)|<br>|…|…|…|<br>|第h层|2k^h-2|2k^h-2(k-1)|</p>
<h2 id="B树的插入删除"><a href="#B树的插入删除" class="headerlink" title="B树的插入删除"></a>B树的插入删除</h2><ol>
<li><p>插入</p>
<ul>
<li>只能插入到<strong>终端节点</strong>（满足叶子节点性质）</li>
<li>节点数目超过上限时，进行<strong>分裂</strong>：选择<img src="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20log_2%20m%5Cbiggr%5Crceil">节点插入到父节点合适位置维持有序性（可能持续分裂，根节点分裂将导致树高度+1）</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>终端关键字删除：<ul>
<li>未低于下限：无需处理</li>
<li><strong>低于下限：</strong><br> ①兄弟节点够借：需要变动前驱与前驱的前驱/后继与后继的后继<br> ②兄弟节点不够借：将自己与兄弟节点、父节点关键字合并为一个节点（可能持续合并，合并到根节点会导致树高度-1）</li>
</ul>
</li>
<li>非终端关键字删除：<ul>
<li>类似BST删除，以<strong>直接前驱/直接后继</strong>进行替换。转化为终端关键字删除</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>对于一个m阶B+树：</p>
<ul>
<li>每个分支节点最多有m棵子树</li>
<li>非叶根节点最少2棵子树，其余分支节点至少<img src="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clceil%20log_2%20m%5Cbiggr%5Crceil">棵子树</li>
<li><strong>节点的子树个数与关键字个数相等</strong></li>
<li>叶子节点包含全部关键字及相应的指针，同时相邻叶节点按大小顺序链接起来（支持顺序<strong>查找</strong>）</li>
<li>（具有类似<strong>分块查找</strong>的性质）</li>
</ul>
<p>查找：</p>
<ul>
<li>B+：多路查找，分支仅起索引作用</li>
<li>典型应用：MySQL索引。（相比B树不包含分支对应记录的存储地址，因此可以使得磁盘包含更多关键字，使树高更矮，读磁盘次数更少，查找效率更高）</li>
</ul>
<h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><ol>
<li>构造hash表<ul>
<li>除留余数法</li>
<li>直接法</li>
<li>数据分析法</li>
<li>平方法</li>
</ul>
</li>
<li>冲突处理<ul>
<li>拉链法</li>
<li>开放定址法（线性探测、平方探测、伪随机数）</li>
</ul>
</li>
<li>查找效率分析<ul>
<li>装填因子</li>
</ul>
</li>
</ol>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：<ul>
<li>最好（有序）：O(n)</li>
<li>最坏（逆序）/平均：O(n^2)</li>
</ul>
</li>
<li>稳定<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> q[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=q[i], j=i;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;tmp&lt;q[j<span class="number">-1</span>])&#123; <span class="comment">//注意</span></span><br><span class="line">			q[j]=q[j<span class="number">-1</span>];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		q[j]=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7 3 6 2 5 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">insert_sort</span>(q);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>折半插入排序：将元素放到q[low]的位置后移[low,i-1]；相等元素q[low+1]=tmp</li>
<li>链表插入排序</li>
</ul>
<h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><blockquote>
<p>淦，在这里反复错了好多次然后才改对的</p>
</blockquote>
<ul>
<li>时间复杂度：与d的选择有关；最坏情况退化为直接插入排序</li>
<li>不稳定<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> q[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> d=n/<span class="number">2</span>; d&gt;=<span class="number">1</span>; d/=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>+d; i&lt;=n; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp=q[i], j=i;</span><br><span class="line">			<span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;tmp&lt;q[j-d])&#123;  <span class="comment">// 这里错了一直没发现</span></span><br><span class="line">				q[j]=q[j-d];</span><br><span class="line">				j-=d;</span><br><span class="line">			&#125;</span><br><span class="line">			q[j]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>只适用于<strong>顺序表</strong>：需要有增量d，因此需要有随机访问的特性</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>时间复杂度：<ul>
<li>最好情况（有序）：O(n)</li>
<li>最坏情况（逆序）：O(n^2)</li>
</ul>
</li>
<li>未发生交换可以提前结束</li>
<li>稳定</li>
<li>链表</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>时间复杂度：<ul>
<li>若基准元素能够将区间划分为均匀两部分则效率最高</li>
<li>若本身有序或逆序，则效率最低</li>
</ul>
</li>
<li>不稳定</li>
</ul>
<p><strong>补充：</strong> 二叉树最小高度：<br><img src="https://latex.codecogs.com/svg.latex?%5Cbiggl%5Clfloor%20log_2%20n%5Cbiggr%5Crfloor+1">；<br>最大高度：n</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><ul>
<li>时间复杂度：在有序无序情况下运算情况一致，复杂度始终为o(n^2)</li>
<li>不稳定</li>
<li>链表</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>初始化等操作见另一blog</li>
<li>时间复杂度：<ul>
<li>建堆：O(n)；排序：O(nlogn)</li>
<li>总：O(nlogn)</li>
</ul>
</li>
<li>不稳定</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul>
<li>空间复杂度：O(n)</li>
<li>时间复杂度：O(nlogn)</li>
<li>稳定</li>
</ul>
<h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h2><ul>
<li>唯一不是基于比较的排序；使用关键字进行排序</li>
<li>用于链式存储结构<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示每一个元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span>, <span class="title">tail</span>;</span></span><br><span class="line">&#125;q[N];</span><br></pre></td></tr></table></figure></li>
<li>空间复杂度：O(r)</li>
<li>时间复杂度：<ul>
<li>分配：O(n)，收集：O(r)；总共d趟分配收集，所以总时间复杂度O(d(n+r))</li>
</ul>
</li>
<li>稳定</li>
<li>适用问题：<ul>
<li>关键字可以拆分为d组，且d较小</li>
<li>每组关键字取值范围不大，即r较小</li>
<li>数据个数n较大</li>
</ul>
</li>
</ul>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>归并排序–优化：多路归并（增加输入缓冲区）</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>


<script src="../../../../js/vdonate.js"></script>

<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://pic3.zhimg.com/80/v2-ea5bb2685f8c6ad3392bfcb76a70e9d7_720w.jpg?source=1940ef5c',
  alipayImage: 'https://pic3.zhimg.com/80/v2-7feeffaa075f9813a3c562abbd4b655c_720w.jpg?source=1940ef5c'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>bowlmeat</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2022/07/19/Data-Structure-by-CSKaoYan/" target="_blank" title="Data Structure by CSKaoYan">https://bowlmeat.github.io/2022/07/19/Data-Structure-by-CSKaoYan/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/%E5%86%85%E5%8A%9F/" rel="tag">内功</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../../21/Algorithms/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          常见入门算法
        
      </div>
    </a>
  
  
    <a href="../Data-Structure-And-Algorithms/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Data Structure And Algorithms</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.1.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">线索二叉树的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">线索二叉树的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">线索二叉树的存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">二叉树的线索化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7"><span class="nav-number">1.4.</span> <span class="nav-text">在线索二叉树中找前驱后继</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.6.</span> <span class="nav-text">树与森林的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#127800-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="nav-number">1.7.</span> <span class="nav-text">🌸二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BST%E6%9F%A5%E6%89%BE"><span class="nav-number">1.7.1.</span> <span class="nav-text">BST查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BST%E6%8F%92%E5%85%A5%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="nav-number">1.7.2.</span> <span class="nav-text">BST插入与构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="nav-number">1.7.3.</span> <span class="nav-text">查找效率分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.8.</span> <span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%8A%82BST%E8%87%B3AVL"><span class="nav-number">1.8.1.</span> <span class="nav-text">调节BST至AVL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-1"><span class="nav-number">1.8.2.</span> <span class="nav-text">查找效率分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.9.</span> <span class="nav-text">哈夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="nav-number">1.9.1.</span> <span class="nav-text">带权路径长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="nav-number">1.9.2.</span> <span class="nav-text">哈夫曼树定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0"><span class="nav-number">1.9.3.</span> <span class="nav-text">哈夫曼树构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">1.9.4.</span> <span class="nav-text">哈夫曼编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">2.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">3.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">3.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">3.2.</span> <span class="nav-text">折半查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-number">3.3.</span> <span class="nav-text">分块查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91"><span class="nav-number">3.4.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="nav-number">3.5.</span> <span class="nav-text">B树的插入删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">3.6.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="nav-number">3.7.</span> <span class="nav-text">散列查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">4.1.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-Shell-Sort"><span class="nav-number">4.2.</span> <span class="nav-text">希尔排序(Shell Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">4.3.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">4.4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">4.5.</span> <span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">4.6.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.7.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radix-Sort"><span class="nav-number">4.8.</span> <span class="nav-text">基数排序(Radix Sort)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">4.9.</span> <span class="nav-text">外部排序</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2022 Bowlmeat&#39;s Blogs All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">Home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">Archives</a>
  
    <a href="../../../../categories" class="mobile-nav-link">Categories</a>
  
    <a href="../../../../tags" class="mobile-nav-link">Tags</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/scripts.js"></script>





  
<script src="../../../../js/dialog.js"></script>









	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Bowlmeat&#39;s Blogs
          </div>
          <div class="panel-body">
            Copyright © 2022 bowlmeat All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>